// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: merlion/maker/v1/maker.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BackingRiskParams represents an object of backing coin risk parameters.
type BackingRiskParams struct {
	// backing coin denom
	BackingDenom string `protobuf:"bytes,1,opt,name=backing_denom,json=backingDenom,proto3" json:"backing_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total backing amount
	MaxBacking *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=max_backing,json=maxBacking,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_backing,omitempty"`
	// maximum mintable Mer amount
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_mer_mint,omitempty"`
	// mint fee rate
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// burn fee rate
	BurnFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=burn_fee,json=burnFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_fee,omitempty"`
	// buyback fee rate
	BuybackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=buyback_fee,json=buybackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"buyback_fee,omitempty"`
	// recollateralize fee rate
	RecollateralizeFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=recollateralize_fee,json=recollateralizeFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"recollateralize_fee,omitempty"`
	// mint Mer price threshold
	MintPriceThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=mint_price_threshold,json=mintPriceThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_price_threshold,omitempty"`
	// burn Mer price threshold
	BurnPriceThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=burn_price_threshold,json=burnPriceThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_price_threshold,omitempty"`
}

func (m *BackingRiskParams) Reset()         { *m = BackingRiskParams{} }
func (m *BackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BackingRiskParams) ProtoMessage()    {}
func (*BackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{0}
}
func (m *BackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackingRiskParams.Merge(m, src)
}
func (m *BackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BackingRiskParams proto.InternalMessageInfo

func (m *BackingRiskParams) GetBackingDenom() string {
	if m != nil {
		return m.BackingDenom
	}
	return ""
}

func (m *BackingRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// CollateralRiskParams represents an object of collateral risk parameters.
type CollateralRiskParams struct {
	// collateral coin denom
	CollateralDenom string `protobuf:"bytes,1,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total collateral amount
	MaxCollateral *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=max_collateral,json=maxCollateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_collateral,omitempty"`
	// maximum total mintable Mer amount
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_mer_mint,omitempty"`
	// ratio at which a position is defined as undercollateralized
	LiquidationThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidation_threshold,json=liquidationThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_threshold,omitempty"`
	// maximum ratio of maximum amount of currency that can be borrowed with a specific collateral
	LoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=loan_to_value,json=loanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"loan_to_value,omitempty"`
	// basic ratio of maximum amount of currency that can be borrowed with a specific collateral
	BasicLoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=basic_loan_to_value,json=basicLoanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"basic_loan_to_value,omitempty"`
	// catalytic ratio of burned Lion to minted stablecoins, to maximize the LTV in [basic-LTV, LTV]
	CatalyticLionRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=catalytic_lion_ratio,json=catalyticLionRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"catalytic_lion_ratio,omitempty"`
	// liquidation fee rate, i.e., the discount a liquidator gets when buying collateral flagged for a liquidation
	LiquidationFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=liquidation_fee,json=liquidationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_fee,omitempty"`
	// mint fee rate, i.e., extra fee debt
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// annual interest fee rate (APR)
	InterestFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=interest_fee,json=interestFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"interest_fee,omitempty"`
}

func (m *CollateralRiskParams) Reset()         { *m = CollateralRiskParams{} }
func (m *CollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*CollateralRiskParams) ProtoMessage()    {}
func (*CollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{1}
}
func (m *CollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralRiskParams.Merge(m, src)
}
func (m *CollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralRiskParams proto.InternalMessageInfo

func (m *CollateralRiskParams) GetCollateralDenom() string {
	if m != nil {
		return m.CollateralDenom
	}
	return ""
}

func (m *CollateralRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// RegisterBacking is a gov Content type to register eligible strong-backing asset with backing risk parameters.
type RegisterBackingProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams *BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *RegisterBackingProposal) Reset()         { *m = RegisterBackingProposal{} }
func (m *RegisterBackingProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterBackingProposal) ProtoMessage()    {}
func (*RegisterBackingProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{2}
}
func (m *RegisterBackingProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterBackingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterBackingProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterBackingProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterBackingProposal.Merge(m, src)
}
func (m *RegisterBackingProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterBackingProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterBackingProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterBackingProposal proto.InternalMessageInfo

func (m *RegisterBackingProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterBackingProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterBackingProposal) GetRiskParams() *BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// RegisterCollateral is a gov Content type to register eligible collateral with collateral risk parameters.
type RegisterCollateralProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams *CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *RegisterCollateralProposal) Reset()         { *m = RegisterCollateralProposal{} }
func (m *RegisterCollateralProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterCollateralProposal) ProtoMessage()    {}
func (*RegisterCollateralProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{3}
}
func (m *RegisterCollateralProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterCollateralProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterCollateralProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterCollateralProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterCollateralProposal.Merge(m, src)
}
func (m *RegisterCollateralProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterCollateralProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterCollateralProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterCollateralProposal proto.InternalMessageInfo

func (m *RegisterCollateralProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterCollateralProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterCollateralProposal) GetRiskParams() *CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// SetBackingRiskParams is a gov Content type to set backing coin risk parameters.
type SetBackingRiskParams struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams *BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *SetBackingRiskParams) Reset()         { *m = SetBackingRiskParams{} }
func (m *SetBackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*SetBackingRiskParams) ProtoMessage()    {}
func (*SetBackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{4}
}
func (m *SetBackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBackingRiskParams.Merge(m, src)
}
func (m *SetBackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *SetBackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_SetBackingRiskParams proto.InternalMessageInfo

func (m *SetBackingRiskParams) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetBackingRiskParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetBackingRiskParams) GetRiskParams() *BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// SetCollateralRiskParams is a gov Content type to set collateral risk parameters.
type SetCollateralRiskParams struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams *CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *SetCollateralRiskParams) Reset()         { *m = SetCollateralRiskParams{} }
func (m *SetCollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*SetCollateralRiskParams) ProtoMessage()    {}
func (*SetCollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{5}
}
func (m *SetCollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCollateralRiskParams.Merge(m, src)
}
func (m *SetCollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *SetCollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_SetCollateralRiskParams proto.InternalMessageInfo

func (m *SetCollateralRiskParams) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetCollateralRiskParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetCollateralRiskParams) GetRiskParams() *CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetBackingRiskParams is a gov Content type to batch set backing coin risk parameters.
type BatchSetBackingRiskParams struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []*BackingRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *BatchSetBackingRiskParams) Reset()         { *m = BatchSetBackingRiskParams{} }
func (m *BatchSetBackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchSetBackingRiskParams) ProtoMessage()    {}
func (*BatchSetBackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{6}
}
func (m *BatchSetBackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetBackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetBackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetBackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBackingRiskParams.Merge(m, src)
}
func (m *BatchSetBackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetBackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBackingRiskParams proto.InternalMessageInfo

func (m *BatchSetBackingRiskParams) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetBackingRiskParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetBackingRiskParams) GetRiskParams() []*BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetCollateralRiskParams is a gov Content type to batch set collateral risk parameters.
type BatchSetCollateralRiskParams struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []*CollateralRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *BatchSetCollateralRiskParams) Reset()         { *m = BatchSetCollateralRiskParams{} }
func (m *BatchSetCollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchSetCollateralRiskParams) ProtoMessage()    {}
func (*BatchSetCollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{7}
}
func (m *BatchSetCollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetCollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetCollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetCollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetCollateralRiskParams.Merge(m, src)
}
func (m *BatchSetCollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetCollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetCollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetCollateralRiskParams proto.InternalMessageInfo

func (m *BatchSetCollateralRiskParams) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetCollateralRiskParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetCollateralRiskParams) GetRiskParams() []*CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

func init() {
	proto.RegisterType((*BackingRiskParams)(nil), "merlion.maker.v1.BackingRiskParams")
	proto.RegisterType((*CollateralRiskParams)(nil), "merlion.maker.v1.CollateralRiskParams")
	proto.RegisterType((*RegisterBackingProposal)(nil), "merlion.maker.v1.RegisterBackingProposal")
	proto.RegisterType((*RegisterCollateralProposal)(nil), "merlion.maker.v1.RegisterCollateralProposal")
	proto.RegisterType((*SetBackingRiskParams)(nil), "merlion.maker.v1.SetBackingRiskParams")
	proto.RegisterType((*SetCollateralRiskParams)(nil), "merlion.maker.v1.SetCollateralRiskParams")
	proto.RegisterType((*BatchSetBackingRiskParams)(nil), "merlion.maker.v1.BatchSetBackingRiskParams")
	proto.RegisterType((*BatchSetCollateralRiskParams)(nil), "merlion.maker.v1.BatchSetCollateralRiskParams")
}

func init() { proto.RegisterFile("merlion/maker/v1/maker.proto", fileDescriptor_ee82e911d469b50f) }

var fileDescriptor_ee82e911d469b50f = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0x5d, 0x4b, 0x1b, 0x4d,
	0x14, 0xc7, 0xb3, 0x8f, 0xef, 0x67, 0x7d, 0x7b, 0xd6, 0x7d, 0x70, 0x1f, 0x91, 0x28, 0x0a, 0x62,
	0x0b, 0x26, 0xd8, 0xde, 0xf5, 0x32, 0xb5, 0x7a, 0xa1, 0x16, 0xbb, 0x4a, 0xa1, 0xad, 0xb0, 0xcc,
	0x6e, 0x4e, 0x93, 0x21, 0xbb, 0x3b, 0xe9, 0xcc, 0x44, 0xa2, 0x9f, 0xa2, 0xd7, 0x85, 0x52, 0xa1,
	0xf4, 0xbb, 0xf4, 0xd2, 0xbb, 0x96, 0x5e, 0x94, 0xa2, 0x17, 0xed, 0xc7, 0x28, 0xb3, 0x99, 0x24,
	0xab, 0x06, 0xca, 0xc6, 0x0a, 0x5e, 0x65, 0xe6, 0x64, 0xcf, 0x8f, 0x33, 0xff, 0x3d, 0xff, 0x33,
	0x0b, 0xf3, 0x11, 0xf2, 0x90, 0xb2, 0xb8, 0x18, 0x91, 0x1a, 0xf2, 0xe2, 0xd1, 0x7a, 0x6b, 0x51,
	0xa8, 0x73, 0x26, 0x99, 0x35, 0xad, 0xff, 0x2d, 0xb4, 0x82, 0x47, 0xeb, 0x73, 0x76, 0x85, 0x55,
	0x58, 0xf2, 0x67, 0x51, 0xad, 0x5a, 0xcf, 0x2d, 0xfd, 0x1c, 0x82, 0x7f, 0x4b, 0x24, 0xa8, 0xd1,
	0xb8, 0xe2, 0x52, 0x51, 0xdb, 0x23, 0x9c, 0x44, 0xc2, 0x5a, 0x86, 0x09, 0xbf, 0x15, 0xf4, 0xca,
	0x18, 0xb3, 0xc8, 0x31, 0x16, 0x8d, 0xd5, 0x31, 0x77, 0x5c, 0x07, 0x37, 0x54, 0xcc, 0x72, 0x60,
	0x04, 0x63, 0xe2, 0x87, 0x58, 0x76, 0xfe, 0x59, 0x34, 0x56, 0x47, 0xdd, 0xf6, 0xd6, 0xda, 0x06,
	0x33, 0x22, 0x4d, 0x4f, 0x3f, 0xed, 0x0c, 0xa8, 0xe4, 0xd2, 0xfd, 0x6f, 0xdf, 0x17, 0x56, 0x2a,
	0x54, 0x56, 0x1b, 0x7e, 0x21, 0x60, 0x51, 0x31, 0x60, 0x22, 0x62, 0x42, 0xff, 0xac, 0x89, 0x72,
	0xad, 0x28, 0x8f, 0xeb, 0x28, 0x0a, 0x1b, 0x18, 0xb8, 0x10, 0x91, 0xa6, 0xae, 0xca, 0xda, 0x81,
	0x71, 0x05, 0x8b, 0x90, 0x7b, 0x11, 0x8d, 0xa5, 0x33, 0xd8, 0x17, 0x6d, 0x17, 0xf9, 0x2e, 0x8d,
	0xa5, 0xf5, 0x04, 0x46, 0x15, 0xc5, 0x7b, 0x8d, 0xe8, 0x0c, 0x65, 0x26, 0x8d, 0xa8, 0xdc, 0x4d,
	0x44, 0x85, 0xf1, 0x1b, 0x3c, 0x4e, 0x30, 0xc3, 0xd9, 0x31, 0x2a, 0x57, 0x61, 0xb6, 0xc1, 0xf4,
	0x1b, 0xc7, 0x4a, 0xa7, 0x84, 0x34, 0x92, 0xfd, 0x68, 0x3a, 0x5d, 0xc1, 0x5e, 0xc1, 0x0c, 0xc7,
	0x80, 0x85, 0x21, 0x91, 0xc8, 0x49, 0x48, 0x4f, 0x30, 0x81, 0x8e, 0x66, 0x86, 0x5a, 0x57, 0x30,
	0x0a, 0x7e, 0x08, 0x76, 0xa2, 0x5b, 0x9d, 0xd3, 0x00, 0x3d, 0x59, 0xe5, 0x28, 0xaa, 0x2c, 0x2c,
	0x3b, 0x63, 0xd9, 0xe9, 0x8a, 0xb3, 0xa7, 0x30, 0x07, 0x6d, 0x8a, 0xa2, 0x27, 0x72, 0x5e, 0xa5,
	0x43, 0x76, 0xba, 0xe2, 0x5c, 0xa6, 0x3f, 0x1a, 0xfc, 0x75, 0xba, 0x90, 0x5b, 0xfa, 0x32, 0x0c,
	0xf6, 0xe3, 0xce, 0xb1, 0x52, 0xcd, 0x7e, 0x0f, 0xa6, 0xbb, 0xc7, 0xbd, 0xd4, 0xef, 0x53, 0xdd,
	0xf8, 0x9f, 0x5a, 0xfe, 0x19, 0x4c, 0xaa, 0x2e, 0xed, 0x26, 0xf4, 0xd1, 0xf5, 0x13, 0x11, 0x69,
	0x76, 0x2b, 0xfc, 0xcb, 0x8d, 0xef, 0xc1, 0x7f, 0x21, 0x7d, 0xd3, 0xa0, 0x65, 0x22, 0x29, 0x8b,
	0x53, 0x1a, 0x67, 0x77, 0x81, 0x9d, 0x02, 0x75, 0xdf, 0xe1, 0x53, 0x98, 0x08, 0x19, 0x89, 0x3d,
	0xc9, 0xbc, 0x23, 0x12, 0x36, 0xfa, 0xf1, 0x85, 0xa9, 0x00, 0x07, 0xec, 0xb9, 0x4a, 0xb7, 0x5e,
	0xc0, 0x8c, 0x4f, 0x04, 0x0d, 0xbc, 0xcb, 0xd4, 0xec, 0x1e, 0x99, 0x4e, 0x30, 0x3b, 0x29, 0xf4,
	0x21, 0xd8, 0x01, 0x91, 0x24, 0x3c, 0x96, 0x0a, 0xaf, 0xe4, 0xe0, 0xea, 0x30, 0xfd, 0x58, 0xa5,
	0xc3, 0xd9, 0xa1, 0x2c, 0x76, 0x15, 0xc5, 0xda, 0x87, 0xa9, 0xb4, 0xd2, 0xca, 0x83, 0xd9, 0x5d,
	0x32, 0x99, 0x42, 0xe8, 0x81, 0xd3, 0x99, 0x5b, 0xd0, 0xff, 0xdc, 0xda, 0x85, 0x71, 0x1a, 0x4b,
	0xe4, 0x28, 0x5a, 0x28, 0x33, 0xfb, 0x3b, 0x6a, 0xe7, 0x6f, 0x22, 0x6a, 0x67, 0xbd, 0x37, 0x60,
	0xd6, 0xc5, 0x0a, 0x15, 0x12, 0xb9, 0x9e, 0xda, 0x7b, 0x9c, 0xd5, 0x99, 0x20, 0xa1, 0x65, 0xc3,
	0x90, 0xa4, 0x32, 0x44, 0xed, 0xa8, 0xd6, 0xc6, 0x5a, 0x04, 0xb3, 0x8c, 0x22, 0xe0, 0xb4, 0xae,
	0xce, 0x97, 0x78, 0x69, 0xcc, 0x4d, 0x87, 0xac, 0x0d, 0x30, 0x39, 0x15, 0x35, 0xaf, 0x9e, 0x78,
	0x34, 0x31, 0x93, 0xf9, 0x60, 0xb9, 0x70, 0xf5, 0x56, 0x2b, 0x5c, 0xbb, 0xbb, 0x5c, 0xe0, 0x9d,
	0xb5, 0xae, 0xef, 0xa3, 0x01, 0x73, 0xed, 0xfa, 0xba, 0xfe, 0xba, 0x71, 0x89, 0x5b, 0xbd, 0x4a,
	0x5c, 0xb9, 0x5e, 0x62, 0xaf, 0xa1, 0xd3, 0xa3, 0xca, 0x77, 0x06, 0xd8, 0xfb, 0x28, 0xaf, 0x5f,
	0xc6, 0x77, 0x41, 0xc2, 0x53, 0x03, 0x66, 0xf7, 0x51, 0xf6, 0x9c, 0x9f, 0x77, 0x44, 0xbf, 0x0f,
	0x06, 0xfc, 0x5f, 0x22, 0x32, 0xa8, 0xde, 0xae, 0x88, 0x03, 0xfd, 0x8b, 0xf8, 0xc9, 0x80, 0xf9,
	0x76, 0x85, 0xb7, 0xab, 0xe4, 0xc0, 0x4d, 0x94, 0x2c, 0x6d, 0x7d, 0x3e, 0xcf, 0x1b, 0x67, 0xe7,
	0x79, 0xe3, 0xc7, 0x79, 0xde, 0x78, 0x7b, 0x91, 0xcf, 0x9d, 0x5d, 0xe4, 0x73, 0x5f, 0x2f, 0xf2,
	0xb9, 0x97, 0x6b, 0xa9, 0x21, 0xa1, 0xe9, 0x6b, 0x27, 0x2c, 0xc6, 0xf6, 0xa6, 0xd8, 0xd4, 0x5f,
	0xa3, 0xc9, 0xbc, 0xf0, 0x87, 0x93, 0x6f, 0xcc, 0x87, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x20,
	0x41, 0x17, 0x0a, 0xab, 0x0a, 0x00, 0x00,
}

func (m *BackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BurnPriceThreshold != nil {
		{
			size := m.BurnPriceThreshold.Size()
			i -= size
			if _, err := m.BurnPriceThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.MintPriceThreshold != nil {
		{
			size := m.MintPriceThreshold.Size()
			i -= size
			if _, err := m.MintPriceThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RecollateralizeFee != nil {
		{
			size := m.RecollateralizeFee.Size()
			i -= size
			if _, err := m.RecollateralizeFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BuybackFee != nil {
		{
			size := m.BuybackFee.Size()
			i -= size
			if _, err := m.BuybackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BurnFee != nil {
		{
			size := m.BurnFee.Size()
			i -= size
			if _, err := m.BurnFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxBacking != nil {
		{
			size := m.MaxBacking.Size()
			i -= size
			if _, err := m.MaxBacking.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BackingDenom) > 0 {
		i -= len(m.BackingDenom)
		copy(dAtA[i:], m.BackingDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.BackingDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterestFee != nil {
		{
			size := m.InterestFee.Size()
			i -= size
			if _, err := m.InterestFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LiquidationFee != nil {
		{
			size := m.LiquidationFee.Size()
			i -= size
			if _, err := m.LiquidationFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CatalyticLionRatio != nil {
		{
			size := m.CatalyticLionRatio.Size()
			i -= size
			if _, err := m.CatalyticLionRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BasicLoanToValue != nil {
		{
			size := m.BasicLoanToValue.Size()
			i -= size
			if _, err := m.BasicLoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LoanToValue != nil {
		{
			size := m.LoanToValue.Size()
			i -= size
			if _, err := m.LoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LiquidationThreshold != nil {
		{
			size := m.LiquidationThreshold.Size()
			i -= size
			if _, err := m.LiquidationThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxCollateral != nil {
		{
			size := m.MaxCollateral.Size()
			i -= size
			if _, err := m.MaxCollateral.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterBackingProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterBackingProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterBackingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterCollateralProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterCollateralProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterCollateralProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetBackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetBackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetBackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetBackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetCollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetCollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetCollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaker(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BackingDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxBacking != nil {
		l = m.MaxBacking.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BurnFee != nil {
		l = m.BurnFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BuybackFee != nil {
		l = m.BuybackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RecollateralizeFee != nil {
		l = m.RecollateralizeFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintPriceThreshold != nil {
		l = m.MintPriceThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BurnPriceThreshold != nil {
		l = m.BurnPriceThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *CollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxCollateral != nil {
		l = m.MaxCollateral.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationThreshold != nil {
		l = m.LiquidationThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LoanToValue != nil {
		l = m.LoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BasicLoanToValue != nil {
		l = m.BasicLoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.CatalyticLionRatio != nil {
		l = m.CatalyticLionRatio.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationFee != nil {
		l = m.LiquidationFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.InterestFee != nil {
		l = m.InterestFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterBackingProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterCollateralProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *SetBackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *SetCollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *BatchSetBackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetCollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func sovMaker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaker(x uint64) (n int) {
	return sovMaker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBacking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MaxBacking = &v
			if err := m.MaxBacking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BurnFee = &v
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuybackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BuybackFee = &v
			if err := m.BuybackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecollateralizeFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RecollateralizeFee = &v
			if err := m.RecollateralizeFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintPriceThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintPriceThreshold = &v
			if err := m.MintPriceThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnPriceThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BurnPriceThreshold = &v
			if err := m.BurnPriceThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCollateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MaxCollateral = &v
			if err := m.MaxCollateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationThreshold = &v
			if err := m.LiquidationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LoanToValue = &v
			if err := m.LoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicLoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BasicLoanToValue = &v
			if err := m.BasicLoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalyticLionRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.CatalyticLionRatio = &v
			if err := m.CatalyticLionRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationFee = &v
			if err := m.LiquidationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.InterestFee = &v
			if err := m.InterestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterBackingProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterBackingProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterBackingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &BackingRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterCollateralProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterCollateralProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterCollateralProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CollateralRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &BackingRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CollateralRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetBackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetBackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetBackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, &BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetCollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, &CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaker = fmt.Errorf("proto: unexpected end of group")
)
