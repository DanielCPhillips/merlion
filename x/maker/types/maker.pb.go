// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: merlion/maker/v1/maker.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BackingRiskParams represents an object of backing coin risk parameters.
type BackingRiskParams struct {
	// backing coin denom
	BackingDenom string `protobuf:"bytes,1,opt,name=backing_denom,json=backingDenom,proto3" json:"backing_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total backing amount
	MaxBacking *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_backing,json=maxBacking,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_backing,omitempty"`
	// maximum mintable Mer amount
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_mer_mint,omitempty"`
	// mint fee rate
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// burn fee rate
	BurnFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=burn_fee,json=burnFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_fee,omitempty"`
	// buyback fee rate
	BuybackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=buyback_fee,json=buybackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"buyback_fee,omitempty"`
	// recollateralize fee rate
	RecollateralizeFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=recollateralize_fee,json=recollateralizeFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"recollateralize_fee,omitempty"`
}

func (m *BackingRiskParams) Reset()         { *m = BackingRiskParams{} }
func (m *BackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BackingRiskParams) ProtoMessage()    {}
func (*BackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{0}
}
func (m *BackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackingRiskParams.Merge(m, src)
}
func (m *BackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BackingRiskParams proto.InternalMessageInfo

func (m *BackingRiskParams) GetBackingDenom() string {
	if m != nil {
		return m.BackingDenom
	}
	return ""
}

func (m *BackingRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// CollateralRiskParams represents an object of collateral risk parameters.
type CollateralRiskParams struct {
	// collateral coin denom
	CollateralDenom string `protobuf:"bytes,1,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total collateral amount
	MaxCollateral *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_collateral,json=maxCollateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_collateral,omitempty"`
	// maximum total mintable Mer amount
	MaxMerMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_mer_mint,json=maxMerMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_mer_mint,omitempty"`
	// ratio at which a position is defined as undercollateralized
	LiquidationThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidation_threshold,json=liquidationThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_threshold,omitempty"`
	// maximum ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	LoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=loan_to_value,json=loanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"loan_to_value,omitempty"`
	// basic ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	BasicLoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=basic_loan_to_value,json=basicLoanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"basic_loan_to_value,omitempty"`
	// catalytic ratio of burned Lion to minted stablecoins, to maximize the LTV
	// in [basic-LTV, LTV]
	CatalyticLionRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=catalytic_lion_ratio,json=catalyticLionRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"catalytic_lion_ratio,omitempty"`
	// liquidation fee rate, i.e., the discount a liquidator gets when buying
	// collateral flagged for a liquidation
	LiquidationFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=liquidation_fee,json=liquidationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_fee,omitempty"`
	// mint fee rate, i.e., extra fee debt
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// annual interest fee rate (APR)
	InterestFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=interest_fee,json=interestFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"interest_fee,omitempty"`
}

func (m *CollateralRiskParams) Reset()         { *m = CollateralRiskParams{} }
func (m *CollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*CollateralRiskParams) ProtoMessage()    {}
func (*CollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{1}
}
func (m *CollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralRiskParams.Merge(m, src)
}
func (m *CollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralRiskParams proto.InternalMessageInfo

func (m *CollateralRiskParams) GetCollateralDenom() string {
	if m != nil {
		return m.CollateralDenom
	}
	return ""
}

func (m *CollateralRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// RegisterBackingProposal is a gov Content type to register eligible
// strong-backing asset with backing risk parameters.
type RegisterBackingProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams *BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *RegisterBackingProposal) Reset()         { *m = RegisterBackingProposal{} }
func (m *RegisterBackingProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterBackingProposal) ProtoMessage()    {}
func (*RegisterBackingProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{2}
}
func (m *RegisterBackingProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterBackingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterBackingProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterBackingProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterBackingProposal.Merge(m, src)
}
func (m *RegisterBackingProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterBackingProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterBackingProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterBackingProposal proto.InternalMessageInfo

func (m *RegisterBackingProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterBackingProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterBackingProposal) GetRiskParams() *BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// RegisterCollateralProposal is a gov Content type to register eligible
// collateral with collateral risk parameters.
type RegisterCollateralProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams *CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *RegisterCollateralProposal) Reset()         { *m = RegisterCollateralProposal{} }
func (m *RegisterCollateralProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterCollateralProposal) ProtoMessage()    {}
func (*RegisterCollateralProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{3}
}
func (m *RegisterCollateralProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterCollateralProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterCollateralProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterCollateralProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterCollateralProposal.Merge(m, src)
}
func (m *RegisterCollateralProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterCollateralProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterCollateralProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterCollateralProposal proto.InternalMessageInfo

func (m *RegisterCollateralProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterCollateralProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterCollateralProposal) GetRiskParams() *CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// SetBackingRiskParamsProposal is a gov Content type to set backing coin risk
// parameters.
type SetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams *BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *SetBackingRiskParamsProposal) Reset()         { *m = SetBackingRiskParamsProposal{} }
func (m *SetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetBackingRiskParamsProposal) ProtoMessage()    {}
func (*SetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{4}
}
func (m *SetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBackingRiskParamsProposal.Merge(m, src)
}
func (m *SetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *SetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetRiskParams() *BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// SetCollateralRiskParamsProposal is a gov Content type to set collateral risk
// parameters.
type SetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams *CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *SetCollateralRiskParamsProposal) Reset()         { *m = SetCollateralRiskParamsProposal{} }
func (m *SetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*SetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{5}
}
func (m *SetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *SetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *SetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetRiskParams() *CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetBackingRiskParamsProposal is a gov Content type to batch set backing
// coin risk parameters.
type BatchSetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []*BackingRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *BatchSetBackingRiskParamsProposal) Reset()         { *m = BatchSetBackingRiskParamsProposal{} }
func (m *BatchSetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetBackingRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{6}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetRiskParams() []*BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetCollateralRiskParamsProposal is a gov Content type to batch set
// collateral risk parameters.
type BatchSetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []*CollateralRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *BatchSetCollateralRiskParamsProposal) Reset()         { *m = BatchSetCollateralRiskParamsProposal{} }
func (m *BatchSetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ee82e911d469b50f, []int{7}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetRiskParams() []*CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

func init() {
	proto.RegisterType((*BackingRiskParams)(nil), "merlion.maker.v1.BackingRiskParams")
	proto.RegisterType((*CollateralRiskParams)(nil), "merlion.maker.v1.CollateralRiskParams")
	proto.RegisterType((*RegisterBackingProposal)(nil), "merlion.maker.v1.RegisterBackingProposal")
	proto.RegisterType((*RegisterCollateralProposal)(nil), "merlion.maker.v1.RegisterCollateralProposal")
	proto.RegisterType((*SetBackingRiskParamsProposal)(nil), "merlion.maker.v1.SetBackingRiskParamsProposal")
	proto.RegisterType((*SetCollateralRiskParamsProposal)(nil), "merlion.maker.v1.SetCollateralRiskParamsProposal")
	proto.RegisterType((*BatchSetBackingRiskParamsProposal)(nil), "merlion.maker.v1.BatchSetBackingRiskParamsProposal")
	proto.RegisterType((*BatchSetCollateralRiskParamsProposal)(nil), "merlion.maker.v1.BatchSetCollateralRiskParamsProposal")
}

func init() { proto.RegisterFile("merlion/maker/v1/maker.proto", fileDescriptor_ee82e911d469b50f) }

var fileDescriptor_ee82e911d469b50f = []byte{
	// 697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0xdd, 0x6a, 0x13, 0x41,
	0x14, 0xc7, 0xb3, 0xf6, 0xfb, 0x6c, 0xbf, 0xdc, 0x46, 0x0c, 0xa5, 0xa4, 0xb5, 0x95, 0x52, 0x85,
	0x26, 0x54, 0xef, 0xbc, 0x8c, 0xb5, 0x45, 0xda, 0x4a, 0xdd, 0x16, 0xc1, 0x0f, 0x58, 0x66, 0x37,
	0xc7, 0x64, 0xc8, 0xee, 0x4c, 0x9c, 0x99, 0x94, 0xb4, 0x4f, 0xe1, 0x0b, 0x08, 0xa2, 0x17, 0x0a,
	0xe2, 0x7b, 0x78, 0xd9, 0x3b, 0xc5, 0x0b, 0x91, 0xf6, 0xc6, 0xc7, 0x90, 0xd9, 0x6c, 0x92, 0x6d,
	0x13, 0x90, 0xdd, 0x4a, 0xe9, 0x55, 0x66, 0xce, 0xec, 0xf9, 0x71, 0xe6, 0xec, 0xff, 0x7f, 0xb2,
	0x30, 0x17, 0xa0, 0xf0, 0x29, 0x67, 0xc5, 0x80, 0xd4, 0x50, 0x14, 0x0f, 0xd6, 0x5a, 0x8b, 0x42,
	0x5d, 0x70, 0xc5, 0xad, 0xe9, 0xe8, 0xb4, 0xd0, 0x0a, 0x1e, 0xac, 0xcd, 0x66, 0x2b, 0xbc, 0xc2,
	0xc3, 0xc3, 0xa2, 0x5e, 0xb5, 0x9e, 0x5b, 0xfc, 0x32, 0x08, 0xd7, 0x4b, 0xc4, 0xab, 0x51, 0x56,
	0xb1, 0xa9, 0xac, 0xed, 0x12, 0x41, 0x02, 0x69, 0x2d, 0xc1, 0x84, 0xdb, 0x0a, 0x3a, 0x65, 0x64,
	0x3c, 0xc8, 0x19, 0x0b, 0xc6, 0xca, 0x98, 0x3d, 0x1e, 0x05, 0xd7, 0x75, 0xcc, 0xca, 0xc1, 0x08,
	0x32, 0xe2, 0xfa, 0x58, 0xce, 0x5d, 0x5b, 0x30, 0x56, 0x46, 0xed, 0xf6, 0xd6, 0xda, 0x02, 0x33,
	0x20, 0x4d, 0x27, 0x7a, 0x3a, 0x37, 0xa0, 0x93, 0x4b, 0x77, 0x7f, 0xfe, 0x9a, 0x5f, 0xae, 0x50,
	0x55, 0x6d, 0xb8, 0x05, 0x8f, 0x07, 0x45, 0x8f, 0xcb, 0x80, 0xcb, 0xe8, 0x67, 0x55, 0x96, 0x6b,
	0x45, 0x75, 0x58, 0x47, 0x59, 0x78, 0xcc, 0x94, 0x0d, 0x01, 0x69, 0x46, 0x55, 0x59, 0xdb, 0x30,
	0xae, 0x61, 0x01, 0x0a, 0x27, 0xa0, 0x4c, 0xe5, 0x06, 0x53, 0xd1, 0x76, 0x50, 0xec, 0x50, 0xa6,
	0xac, 0x47, 0x30, 0xaa, 0x29, 0xce, 0x6b, 0xc4, 0xdc, 0x50, 0x22, 0xd2, 0x3a, 0x7a, 0xf6, 0x88,
	0xce, 0xdd, 0x40, 0xd4, 0x18, 0xb7, 0x21, 0x58, 0x88, 0x19, 0x4e, 0x8e, 0xd1, 0xb9, 0x1a, 0xb3,
	0x05, 0xa6, 0xdb, 0x38, 0xd4, 0x7d, 0x0a, 0x49, 0x23, 0x89, 0x49, 0x10, 0xa5, 0x6b, 0xd8, 0x4b,
	0x98, 0x11, 0xe8, 0x71, 0xdf, 0x27, 0x0a, 0x05, 0xf1, 0xe9, 0x11, 0x86, 0xd0, 0xd1, 0xc4, 0x50,
	0xeb, 0x1c, 0x66, 0x03, 0xf1, 0xc1, 0xe0, 0x9f, 0xf7, 0xf3, 0x99, 0xc5, 0xef, 0xc3, 0x90, 0x7d,
	0xd8, 0x39, 0x8a, 0x09, 0xe6, 0x0e, 0x4c, 0x77, 0x53, 0xce, 0x68, 0x66, 0xaa, 0x1b, 0xff, 0x97,
	0x6c, 0x9e, 0xc2, 0xa4, 0x7e, 0xd3, 0xdd, 0x84, 0x14, 0xca, 0x99, 0x08, 0x48, 0xb3, 0x5b, 0xe1,
	0x7f, 0x16, 0x8f, 0x03, 0x37, 0x7c, 0xfa, 0xa6, 0x41, 0xcb, 0x44, 0x51, 0xce, 0x1c, 0x55, 0x15,
	0x28, 0xab, 0xdc, 0x2f, 0xa7, 0x50, 0x52, 0x36, 0x06, 0xda, 0x6f, 0x73, 0xac, 0x27, 0x30, 0xe1,
	0x73, 0xc2, 0x1c, 0xc5, 0x9d, 0x03, 0xe2, 0x37, 0xd2, 0x68, 0xcb, 0xd4, 0x80, 0x7d, 0xfe, 0x4c,
	0xa7, 0x5b, 0xcf, 0x61, 0xc6, 0x25, 0x92, 0x7a, 0xce, 0x59, 0x6a, 0x72, 0x9d, 0x4d, 0x87, 0x98,
	0xed, 0x18, 0xfa, 0x15, 0x64, 0x3d, 0xa2, 0x88, 0x7f, 0xa8, 0x34, 0x5e, 0xb7, 0x43, 0xe8, 0xcb,
	0xa4, 0x91, 0x5b, 0x87, 0xb3, 0x4d, 0x39, 0xb3, 0x35, 0xc5, 0xda, 0x83, 0xa9, 0x78, 0xa7, 0xb5,
	0x8e, 0xc7, 0x12, 0x83, 0x27, 0x63, 0x88, 0xc8, 0xb4, 0x1d, 0xef, 0x43, 0x7a, 0xef, 0xef, 0xc0,
	0x38, 0x65, 0x0a, 0x05, 0xca, 0x16, 0xca, 0x4c, 0xfe, 0x8e, 0xda, 0xf9, 0x5d, 0x67, 0xbd, 0x33,
	0xe0, 0xa6, 0x8d, 0x15, 0x2a, 0x15, 0x8a, 0x68, 0xf2, 0xed, 0x0a, 0x5e, 0xe7, 0x92, 0xf8, 0x56,
	0x16, 0x86, 0x14, 0x55, 0x3e, 0x46, 0x8e, 0x6a, 0x6d, 0xac, 0x05, 0x30, 0xcb, 0x28, 0x3d, 0x41,
	0xeb, 0xfa, 0x7e, 0xa1, 0x97, 0xc6, 0xec, 0x78, 0xc8, 0x5a, 0x07, 0x53, 0x50, 0x59, 0x73, 0xea,
	0xa1, 0x47, 0x43, 0x33, 0x99, 0xf7, 0x96, 0x0a, 0xe7, 0xff, 0x19, 0x0a, 0x3d, 0xf3, 0xdf, 0x06,
	0xd1, 0x59, 0x47, 0xf5, 0x7d, 0x34, 0x60, 0xb6, 0x5d, 0x5f, 0xd7, 0x5f, 0x17, 0x2e, 0x71, 0xb3,
	0x5f, 0x89, 0xcb, 0xbd, 0x25, 0xf6, 0x1b, 0x3a, 0x7d, 0xaa, 0xfc, 0x60, 0xc0, 0xdc, 0x1e, 0xaa,
	0x9e, 0x0b, 0x5d, 0xa9, 0x56, 0x7e, 0x36, 0x60, 0x7e, 0x0f, 0x55, 0xbf, 0x2b, 0x5d, 0xb5, 0x7e,
	0x7e, 0x32, 0xe0, 0x56, 0x89, 0x28, 0xaf, 0x7a, 0x39, 0x4d, 0x1d, 0x48, 0xdf, 0xd4, 0xaf, 0x06,
	0xdc, 0x6e, 0x57, 0x7a, 0x39, 0x9d, 0x1d, 0xb8, 0x48, 0x67, 0x4b, 0x9b, 0xdf, 0x4e, 0xf2, 0xc6,
	0xf1, 0x49, 0xde, 0xf8, 0x7d, 0x92, 0x37, 0xde, 0x9e, 0xe6, 0x33, 0xc7, 0xa7, 0xf9, 0xcc, 0x8f,
	0xd3, 0x7c, 0xe6, 0xc5, 0x6a, 0x6c, 0x88, 0x44, 0xf4, 0xd5, 0x23, 0xce, 0xb0, 0xbd, 0x29, 0x36,
	0xa3, 0x2f, 0xbe, 0x70, 0x9e, 0xb8, 0xc3, 0xe1, 0x77, 0xdc, 0xfd, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x02, 0x63, 0xe3, 0xef, 0x0f, 0x0a, 0x00, 0x00,
}

func (m *BackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecollateralizeFee != nil {
		{
			size := m.RecollateralizeFee.Size()
			i -= size
			if _, err := m.RecollateralizeFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BuybackFee != nil {
		{
			size := m.BuybackFee.Size()
			i -= size
			if _, err := m.BuybackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BurnFee != nil {
		{
			size := m.BurnFee.Size()
			i -= size
			if _, err := m.BurnFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxBacking != nil {
		{
			size := m.MaxBacking.Size()
			i -= size
			if _, err := m.MaxBacking.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BackingDenom) > 0 {
		i -= len(m.BackingDenom)
		copy(dAtA[i:], m.BackingDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.BackingDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterestFee != nil {
		{
			size := m.InterestFee.Size()
			i -= size
			if _, err := m.InterestFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LiquidationFee != nil {
		{
			size := m.LiquidationFee.Size()
			i -= size
			if _, err := m.LiquidationFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CatalyticLionRatio != nil {
		{
			size := m.CatalyticLionRatio.Size()
			i -= size
			if _, err := m.CatalyticLionRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BasicLoanToValue != nil {
		{
			size := m.BasicLoanToValue.Size()
			i -= size
			if _, err := m.BasicLoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LoanToValue != nil {
		{
			size := m.LoanToValue.Size()
			i -= size
			if _, err := m.LoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LiquidationThreshold != nil {
		{
			size := m.LiquidationThreshold.Size()
			i -= size
			if _, err := m.LiquidationThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMerMint != nil {
		{
			size := m.MaxMerMint.Size()
			i -= size
			if _, err := m.MaxMerMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxCollateral != nil {
		{
			size := m.MaxCollateral.Size()
			i -= size
			if _, err := m.MaxCollateral.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterBackingProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterBackingProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterBackingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterCollateralProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterCollateralProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterCollateralProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaker(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BackingDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxBacking != nil {
		l = m.MaxBacking.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BurnFee != nil {
		l = m.BurnFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BuybackFee != nil {
		l = m.BuybackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RecollateralizeFee != nil {
		l = m.RecollateralizeFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *CollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxCollateral != nil {
		l = m.MaxCollateral.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxMerMint != nil {
		l = m.MaxMerMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationThreshold != nil {
		l = m.LiquidationThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LoanToValue != nil {
		l = m.LoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BasicLoanToValue != nil {
		l = m.BasicLoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.CatalyticLionRatio != nil {
		l = m.CatalyticLionRatio.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationFee != nil {
		l = m.LiquidationFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.InterestFee != nil {
		l = m.InterestFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterBackingProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterCollateralProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *SetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *SetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *BatchSetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func sovMaker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaker(x uint64) (n int) {
	return sovMaker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBacking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxBacking = &v
			if err := m.MaxBacking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BurnFee = &v
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuybackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BuybackFee = &v
			if err := m.BuybackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecollateralizeFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RecollateralizeFee = &v
			if err := m.RecollateralizeFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCollateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxCollateral = &v
			if err := m.MaxCollateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMerMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxMerMint = &v
			if err := m.MaxMerMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationThreshold = &v
			if err := m.LiquidationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LoanToValue = &v
			if err := m.LoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicLoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BasicLoanToValue = &v
			if err := m.BasicLoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalyticLionRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.CatalyticLionRatio = &v
			if err := m.CatalyticLionRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationFee = &v
			if err := m.LiquidationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.InterestFee = &v
			if err := m.InterestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterBackingProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterBackingProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterBackingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &BackingRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterCollateralProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterCollateralProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterCollateralProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CollateralRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &BackingRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CollateralRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, &BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, &CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaker = fmt.Errorf("proto: unexpected end of group")
)
